import { ASYNC_RESPONSE, BOUND_DATA, CARTESIAN2, CELL_PARAMETERS, DEVIATION, DOUBLE_CHECK_CELLS, FROM_TO, FROM_TO_3D, ID_TYPE, MAP, MATRIX_DATA_3D, NFZ_DATA, PERIMETER_DATA, POINT, POINT3D, RANGE, RANGE_CARTESIAN2, TOP_LEFT_BOTTOM_RIGHT } from '../../typings/all.typings';
export declare class MatrixUtility {
    private static instance;
    private constructor();
    private checkIsNotCrossNfzMatrix_3D;
    private checkLeftRightCells_3D_newLogic;
    private checkTopBottomCells_3D_newLogic;
    private static getRange;
    private checkCellNfz_3D;
    private computeCrossPoint;
    private findNearestPointOutsideNFZ;
    private cartographicToMatrix;
    private matrixToCartographicCenterCell;
    private matrixToCartographic;
    private logicIncrementDeviation;
    private checkPartOfArea_singleNFZ;
    private isNeedToCheckCell;
    private setCellByNfz;
    private buildCellPoints;
    private computeBounds;
    private checkOutsideNfzMatirxPoint;
    private checkRoute_3D;
    private cartographicPathToMatrix;
    private resetCell;
    private resetArea;
    private pathToRelativeBase;
    static checkIsNotCrossNfzMatrix_3D: (matrixLline: FROM_TO_3D, matrix: MAP<MAP<number>>, height: number) => boolean;
    static checkLeftRightCells_3D_newLogic: (crossPoint: POINT, matrix: MAP<MAP<number>>, height: number) => DOUBLE_CHECK_CELLS;
    static checkTopBottomCells_3D_newLogic: (crossPoint: POINT, matrix: MAP<MAP<number>>, height: number) => DOUBLE_CHECK_CELLS;
    static checkCellNfz_3D: (cell: POINT, matrix: MAP<MAP<number>>, height: number) => boolean;
    static computeCrossPoint: (matrixLine0: FROM_TO<POINT3D | POINT>, matrixLine1: FROM_TO<POINT3D | POINT>, range: RANGE_CARTESIAN2) => POINT;
    static cartographicToMatrix: (point: (POINT | POINT3D), site: CELL_PARAMETERS) => POINT;
    static checkPartOfArea_singleNFZ: (emptySite: MATRIX_DATA_3D, matrixDataMAP: MAP<MATRIX_DATA_3D>, nfzRectangleRangeMatrix: TOP_LEFT_BOTTOM_RIGHT, nfz: NFZ_DATA, heightRange: RANGE) => MAP<MATRIX_DATA_3D>;
    static findNearestPointOutsideNFZ: (site: MATRIX_DATA_3D, cartographicPoint: (POINT | POINT3D), height: number) => ASYNC_RESPONSE<POINT3D>;
    static logicIncrementDeviation: (deviation?: DEVIATION) => DEVIATION;
    static computeBounds: (perimeterData: PERIMETER_DATA) => BOUND_DATA;
    static checkOutsideNfzMatirxPoint: (matrixPoint: POINT, site: MATRIX_DATA_3D, height: number) => boolean;
    static checkRoute_3D: (route: POINT[], site: MATRIX_DATA_3D, height: number) => boolean;
    static resetArea: (emptySite: MATRIX_DATA_3D, matrixDataMAP: MAP<MATRIX_DATA_3D>, nfzRectangleRangeMatrix: TOP_LEFT_BOTTOM_RIGHT, allowedIdIgnore: ID_TYPE) => void;
    static matrixToCartographic: (site: CELL_PARAMETERS, point: (POINT | POINT3D)) => POINT3D;
    static pathToRelativeBase: (path: POINT3D[], factor: CARTESIAN2) => POINT3D[];
}

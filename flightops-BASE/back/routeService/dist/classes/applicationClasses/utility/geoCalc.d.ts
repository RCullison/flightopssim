import { GeoLineString } from '../../dataClasses/geo/geoLineString';
import { CARTESIAN2, FROM_TO_3D, GEOJSON_POINT, GEOJSON_POLYGON, GEOJSON_POLYLINE, GEOPOINT, POINT, POINT3D, POINT_ON_PATH, POINT_ON_PATH_FOR_AGL } from '../../typings/all.typings';
import { GeoPoint } from '../../dataClasses/geo/geoPoint';
import { GeoPolygon } from '../../dataClasses/geo/geoPolygon';
export declare class GeoCalc {
    private static instance;
    private constructor();
    static calcDestination(_startPoint: POINT | POINT3D, distance: number, bearing: number): POINT;
    static convertMetersToDegree(point: POINT | POINT3D, distance: number, bearing: number): CARTESIAN2;
    static calcDistance(startPoint: POINT | POINT3D, endPoint: POINT | POINT3D): number;
    static removeClosePointsFromRoute: (route: POINT3D[]) => POINT3D[];
    static calcDistanceSimple(startPoint: POINT | POINT3D, endPoint: POINT | POINT3D): number;
    static polylineGetLength: (points: (POINT | POINT3D)[]) => number;
    static calcBearing(startPoint: GEOJSON_POINT, endPoint: GEOJSON_POINT): number;
    static turfPolylineGetLength: (points: (POINT | POINT3D)[]) => number;
    static nearestPointOnLine(line: (POINT | POINT3D)[], point: (POINT | POINT3D)): GEOJSON_POINT;
    static lineSliceAlong(line: (POINT | POINT3D)[], start?: number, stop?: number): GEOJSON_POLYLINE;
    static lineSlice(line: (POINT | POINT3D)[], start: (POINT | POINT3D), stop: (POINT | POINT3D)): GeoLineString;
    static distanceFromStartLine(line: (POINT | POINT3D)[], stop: POINT): number;
    static lineSliceFromStart(line: (POINT | POINT3D)[], stop: POINT): GeoLineString;
    static along(line: (POINT | POINT3D)[], distance?: number): POINT;
    static convertPathToPathResolutionFull: (pathForCompute: (POINT_ON_PATH_FOR_AGL | POINT_ON_PATH)[], distance: number) => POINT_ON_PATH_FOR_AGL[];
    static filterClosePoints: (resultArray: POINT_ON_PATH_FOR_AGL[], minDistance: number) => POINT_ON_PATH_FOR_AGL[];
    static alongArr(pathForCompute: (POINT_ON_PATH_FOR_AGL | POINT_ON_PATH)[], distance?: number): POINT_ON_PATH_FOR_AGL[];
    static isPointInPolygon: (point: POINT | POINT3D, polygon: (POINT | POINT3D)[]) => boolean;
    static polygonDifference: (polygon1: GEOJSON_POLYGON | GeoPolygon, polygon2: GEOJSON_POLYGON | GeoPolygon) => GEOJSON_POLYGON;
    static shortestPath: (start: POINT, end: POINT, NFZs?: POINT[][]) => GeoLineString;
    static booleanContains: (polygon1: GEOJSON_POLYGON | GeoPolygon, polygon2: GEOJSON_POLYGON | GeoPolygon) => boolean;
    static booleanContains_bidirectional: (polygon1: GEOJSON_POLYGON | GeoPolygon, polygon2: GEOJSON_POLYGON | GeoPolygon) => boolean;
    static booleanContains_POINTS_Arr_bidirectional: (polygon1: (POINT | POINT3D)[], polygon2: (POINT | POINT3D)[]) => boolean;
    static booleanOverlap: (polygon1: GEOJSON_POLYGON | GeoPolygon, polygon2: GEOJSON_POLYGON | GeoPolygon) => boolean;
    static circle: (centerPoint: (POINT | POINT3D), radius: number, steps?: number) => GEOJSON_POLYGON;
    static lineOffset: (line: (POINT | POINT3D)[], distance: number) => GeoLineString;
    static lineToPolygonWithOffset: (line: POINT3D[], factor: number) => GEOJSON_POLYGON;
    static FromTo_To_PolygonWithOffset: (fromTo: FROM_TO_3D, factor: number) => GEOJSON_POLYGON;
    static union_GeoPolygons: (geoPolygons: (GEOJSON_POLYGON | GeoPolygon)[]) => GEOJSON_POLYGON;
    static union_GeoLineString: (firstLine: GeoLineString, secondLine: GeoLineString) => GeoLineString;
    static comparePoints: (point0: POINT | POINT3D, point1: POINT | POINT3D) => boolean;
    static Geopoint_To_turfPoint: (geopoint: GeoPoint) => any;
    static POINT_To_turfPoint: (point: (POINT3D | POINT)) => any;
    static POINTsArr_To_turfPolygon: (polygons: (POINT3D | POINT)[][]) => GEOJSON_POLYGON;
    static GeoPolygon_To_turfPolygon: (polygon: GEOJSON_POLYGON | GeoPolygon) => GEOJSON_POLYGON;
    static GeoPolygon_To_POINTsArrArr: (polygon: GEOJSON_POLYGON | GeoPolygon) => (POINT | POINT3D)[][];
    static POINTs_To_turfLine: (points: (POINT | POINT3D)[]) => any;
    static angleTo180_180: (angle: number) => number;
    static angleTo0_360: (angle: number) => number;
    static filterRoute: (route: POINT3D[]) => POINT3D[];
    static validatePolygonPOINTsArr: (polygon: (POINT | POINT3D)[]) => boolean;
    static validateGeoPolygon: (polygon: GEOJSON_POLYGON | GeoPolygon) => boolean;
    static isPOINTsArray: (points: POINT[] | POINT3D[]) => boolean;
    static isCartographicPOINTsArray: (points: POINT[] | POINT3D[]) => boolean;
    static isCartographicPOINT: (point: POINT | POINT3D) => boolean;
    static isGEOPOINT: (point: GEOPOINT) => boolean;
    static isPOINT: (point: POINT | POINT3D) => boolean;
    static isPOINT_NotZero: (point: POINT | POINT3D) => boolean;
    static checkIfGeoPointValid: (coordinates: GeoPoint) => boolean;
    static turf_pointOnFeature: (points: POINT[]) => any;
    static turf_lineSplit: (line0: (POINT | POINT3D)[], line1: (POINT | POINT3D)[]) => GeoLineString;
    static turf_center: (points: (POINT | POINT3D)[]) => any;
    static turf_centerOfMass: (polygon: (POINT | POINT3D)[]) => any;
    static turf_general: (turnFunctionName: string, parameters: []) => any;
    static turf_pointToLineDistance: (point: (POINT | POINT3D), line: (POINT | POINT3D)[]) => number;
    static turf_transformRotatePolygon: (points: POINT3D[], angle: number, center: POINT | POINT3D) => POINT3D[][];
    static turf_intersect: (polygon1: POINT3D[], polygon2: POINT3D[]) => GEOJSON_POLYGON;
    static turf_transformScale_fromPointsArrArr: (polygon: POINT[], scale?: number) => GEOJSON_POLYGON;
}

import { CARTESIAN1, CARTESIAN2, POINT, POINT3D, RANGE, RANGE_CARTESIAN2, TOP_LEFT_BOTTOM_RIGHT, VECTOR } from '../../typings/all.typings';
export declare class CartesianCalc {
    private static instance;
    private constructor();
    static calcDistance(vector: VECTOR): number;
    static vectorAlong(vector: VECTOR, distance?: number): POINT3D;
    private static computeDelta;
    static findFirstAndLastPointsOnLINE(points: POINT3D[]): VECTOR;
    static findFirst_LastDistancesOnVector(points: POINT3D[], vector: VECTOR | POINT3D[]): POINT3D;
    static findPointsCrossVectorAndPolygon(polygon: POINT[], vector: VECTOR | POINT3D[]): POINT[];
    static findNumberOfPointsCrossVectorAndPolygon(polygon: (POINT | POINT3D)[], point: POINT3D | POINT): number;
    static findNumberOfPointsCrossVectorAndPolygonWithoutValidation(polygon: (POINT | POINT3D)[], point: POINT3D | POINT): number;
    static findNumberOfPointsCrossVectorAndPolygonMatrixCartesian(polygon: (POINT | POINT3D)[], point: POINT3D | POINT): number;
    static checkPointInPolygon(polygon: (POINT | POINT3D)[], point: POINT3D | POINT): boolean;
    static checkPointInPolygonWithoutValidation(polygon: (POINT | POINT3D)[], point: POINT3D | POINT): boolean;
    static checkPointInPolygonMatrixCartesian(polygon: (POINT | POINT3D)[], point: POINT3D | POINT): boolean;
    static polygonArea: (polygon: POINT[]) => number;
    static isCrossPolygonAndPolygon(polygon1: (POINT | POINT3D)[], polygon2: (POINT | POINT3D)[]): boolean;
    static isCrossPolygonAndPolygon_withoutCheck(polygon1: (POINT | POINT3D)[], polygon2: (POINT | POINT3D)[]): boolean;
    static isCrossRectangles(firstRectangle: VECTOR | POINT3D[], secondRectangle: VECTOR | POINT3D[]): boolean;
    static isCrossRectangles_withoutCheckValidity(firstRectangle: VECTOR | POINT3D[], secondRectangle: VECTOR | POINT3D[]): boolean;
    static isCrossRectangles_withoutCheckValidity_CARTESIAN2: (firstRectangle: VECTOR<CARTESIAN2> | CARTESIAN2[], secondRectangle: VECTOR<CARTESIAN2> | CARTESIAN2[]) => boolean;
    static isCrossRectangles_withoutCheckValidity_withSevondMinMax(firstRectangle: VECTOR | POINT3D[], secondRectangle: VECTOR | POINT3D[], vectorMinMax: VECTOR<RANGE>): boolean;
    static computeMinMaxVector(rectangle: VECTOR | POINT3D[]): VECTOR<RANGE>;
    static isCrossPolygonsRectangles(firstPolygon: (POINT | POINT3D)[], secondPolygon: (POINT | POINT3D)[]): boolean;
    static isCrossVectorAndPolygon(polygon: (POINT | POINT3D)[], vector: VECTOR | POINT3D[]): boolean;
    static isCrossVectorAndPolygon_withoutCheckValidity(polygon: (POINT | POINT3D)[], vector: VECTOR | POINT3D[]): boolean;
    static checkCrossLines(l1: VECTOR, l2: VECTOR | POINT3D[]): boolean;
    static checkCrossLines_withoutCheckValidity(l1: VECTOR, l2: VECTOR | POINT3D[]): boolean;
    static checkCrossLines_withoutCheckValidity_CARTESIAN2(l1: VECTOR<CARTESIAN2>, l2: VECTOR<CARTESIAN2>): boolean;
    static checkCrossLines_withoutCheckValidity_withMinMaxVector(l1: VECTOR, l2: VECTOR | POINT3D[], vectorMinMax: VECTOR<RANGE>): boolean;
    static checkIntersectPolylines_CARTESIAN2: (firstLine: CARTESIAN2[], secondLine: CARTESIAN2[]) => boolean;
    static checkCrossX: (segment0: VECTOR<CARTESIAN1 | CARTESIAN2>, segment1: VECTOR<CARTESIAN1 | CARTESIAN2>) => boolean;
    static findCrossPoint(v1: VECTOR, v2: VECTOR | POINT3D[]): POINT;
    static checkCrossPolygon(polygon: POINT3D[]): boolean;
    static buildRectangleAroundPoint: (point: POINT3D, rectangleSizeDegree: CARTESIAN2) => POINT3D[];
    static findTopLeftAndBottomRitht: (points: (POINT | POINT3D)[]) => TOP_LEFT_BOTTOM_RIGHT;
    static checkGraphRange: (graphs: CARTESIAN2[][], _factor?: RANGE_CARTESIAN2) => RANGE_CARTESIAN2;
}

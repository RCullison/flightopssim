import { AIR_VEHICLE_ID, ASYNC_RESPONSE, CARTESIAN2, CARTOGRAPHIC_ARR_TO_MATRIX, CARTOGRAPHIC_TO_MATRIX, COMPUTE_ROUTE_REQUEST, DOUBLE_CHECK_CELLS, FROM_TO, FROM_TO_3D, MAP, MATRIX_DATA_3D, MATRIX_DATA_3D_RS, POINT, POINT3D, ROUTE_AIR_VEHICLE, SITE_METADATA, SITE_METADATA_GRID, MATRIX_AND_CARTOGRAPHIC_DATA, ID_TYPE } from '../../../../../classes/typings/all.typings';
export declare class SiteManager {
    private static instance;
    private siteData;
    private constructor();
    private getVersion;
    private getMapMatrixDataFromAMS;
    private getSiteMetadata;
    private getSite;
    private getSiteWithGenerateGrid;
    private getPartOfSiteWithGenerateGrid;
    private getPartOfSiteWithGenerateGrid_filtered;
    private generateSiteMetadataByNewRange;
    private generateSiteByNewRange;
    private convertFromTo_to_MatrixRange;
    private addComputeRouteMargin;
    private generateGridExternal;
    private generateGridExternal_withFiltering;
    private heightToHeightResolution;
    private cartographicToMatrix;
    private cartographicArrToMatrix3D;
    private cartographicToMatrixFunction;
    private cartographicToMatrix3D;
    private checkOutsideNfz;
    private setSites;
    matrixToCartographic: (allowedId: AIR_VEHICLE_ID, point: POINT3D) => POINT3D;
    private checkLeftRightCells;
    private checkTopBottomCells;
    private computeCrossPoint;
    private getMatrix;
    private checkRoute_3D;
    private setFullSiteData;
    static getVersion: () => number;
    static setSites: (data: MAP<MATRIX_DATA_3D>) => ASYNC_RESPONSE;
    static getSite: (allowedId?: AIR_VEHICLE_ID) => MATRIX_DATA_3D_RS;
    static getSiteWithGenerateGrid: (allowedId: AIR_VEHICLE_ID, height: number) => MATRIX_DATA_3D_RS;
    static getPartOfSiteWithGenerateGrid: (allowedId: AIR_VEHICLE_ID, height: number, fromTo: FROM_TO | FROM_TO_3D) => SITE_METADATA_GRID;
    static getPartOfSiteWithGenerateGrid_filtered: (pointsForRoute: COMPUTE_ROUTE_REQUEST, heightASL: number) => SITE_METADATA_GRID;
    static cartographicToMatrix: (requestObj: CARTOGRAPHIC_TO_MATRIX) => POINT3D;
    static checkOutsideNfz: (airVehicleParameters: ROUTE_AIR_VEHICLE, matrixPoint: POINT3D) => boolean;
    static matrixToCartographic: (allowedId: AIR_VEHICLE_ID, point: POINT3D) => POINT3D;
    static computeCrossPoint: (matrixLine0: FROM_TO<POINT3D | POINT>, matrixLine1: FROM_TO<POINT3D | POINT>, matrixSize: CARTESIAN2) => POINT3D;
    static checkLeftRightCells: (crossPoint: POINT3D, matrix: MAP<MAP<number>>, height: number) => DOUBLE_CHECK_CELLS;
    static checkTopBottomCells: (crossPoint: POINT3D, matrix: MAP<MAP<number>>, height: number) => DOUBLE_CHECK_CELLS;
    static getMatrix: (allowedId?: AIR_VEHICLE_ID) => MAP<MAP<number>>;
    static cartographicToMatrixFunction: (point: POINT3D, siteMetadata: SITE_METADATA) => POINT3D;
    static cartographicArrToMatrix3D: (requestObj: CARTOGRAPHIC_ARR_TO_MATRIX) => POINT3D[];
    static setFullSiteData: (fullSiteData: MATRIX_AND_CARTOGRAPHIC_DATA) => ASYNC_RESPONSE;
    static checkRoute_3D: (route: (POINT | POINT3D)[], airVehicleId?: ID_TYPE) => boolean;
}

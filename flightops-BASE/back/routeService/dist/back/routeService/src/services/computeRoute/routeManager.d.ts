import { ASYNC_RESPONSE, COMPUTE_ROUTE, COMPUTE_ROUTE_DIRECTION_REQUEST, COMPUTE_ROUTE_REQUEST, DTM_ROUTE_FULL_DATA, POINT3D, ROUTE_WITH_GRAPH } from '../../../../../classes/typings/all.typings';
export declare class RouteManager {
    private static instance;
    private constructor();
    private computeHeightASLForMatrix;
    private computeHeightASL;
    private computeRoute;
    private computeRouteBypassRelief;
    private computeRouteTerrainFollowingFullPath;
    private computeRouteTerrainFollowingFullPath_floating;
    private validateRequestJson;
    private computeWithDirection;
    private computeWithDirection_floating;
    private findRoute_start_floating;
    private findRoute_start_floating_withDirection;
    private findRoute_finish_floating;
    private findRoute_finish_floating_withDirection;
    private findRoute_finish_floating_followTerrain;
    private findRoute_genery;
    private fixStartFinishPoints;
    private findRoute_start_finish_floating;
    private findRoute_start_finish_floating_withDirection;
    private fixHeightAndAltitudeRange;
    private findRoute_with_static_part;
    private findRoute_with_static_part_start_floating;
    private findRoute_with_static_part_withGraph;
    private addHeight;
    private findRoute_with_static_part_withGraph_floating;
    private findRoute_static_part_graph_start_floating_on_dynamic;
    private validate_findRoute_with_static_part;
    private decrementRouteHeight;
    private convert_COMPUTE_ROUTE_REQUEST_to_Arr;
    private pointsStraightFilter;
    private logStatus;
    static computeRoute: (requestBody: COMPUTE_ROUTE_REQUEST) => ASYNC_RESPONSE<COMPUTE_ROUTE>;
    static computeRouteBypassRelief: (requestBody: COMPUTE_ROUTE_REQUEST) => Promise<ASYNC_RESPONSE<DTM_ROUTE_FULL_DATA>>;
    static computeRouteTerrainFollowingFullPath: (requestBody: COMPUTE_ROUTE_REQUEST) => Promise<ASYNC_RESPONSE<DTM_ROUTE_FULL_DATA>>;
    static computeRouteTerrainFollowingFullPath_floating: (requestBody: COMPUTE_ROUTE_REQUEST) => Promise<ASYNC_RESPONSE<DTM_ROUTE_FULL_DATA>>;
    static computeWithDirection: (requestBody: COMPUTE_ROUTE_DIRECTION_REQUEST) => ASYNC_RESPONSE<COMPUTE_ROUTE>;
    static computeWithDirection_floating: (requestBody: COMPUTE_ROUTE_DIRECTION_REQUEST) => ASYNC_RESPONSE<COMPUTE_ROUTE>;
    static findRoute_start_floating: (requestBody: COMPUTE_ROUTE_REQUEST) => ASYNC_RESPONSE<COMPUTE_ROUTE>;
    static findRoute_start_floating_withDirection: (requestBody: COMPUTE_ROUTE_DIRECTION_REQUEST) => ASYNC_RESPONSE<COMPUTE_ROUTE>;
    static findRoute_finish_floating: (requestBody: COMPUTE_ROUTE_DIRECTION_REQUEST) => Promise<ASYNC_RESPONSE<COMPUTE_ROUTE>>;
    static findRoute_finish_floating_withDirection: (requestBody: COMPUTE_ROUTE_DIRECTION_REQUEST) => Promise<ASYNC_RESPONSE<COMPUTE_ROUTE>>;
    static findRoute_finish_floating_followTerrain: (requestBody: COMPUTE_ROUTE_DIRECTION_REQUEST) => Promise<ASYNC_RESPONSE<COMPUTE_ROUTE>>;
    static findRoute_genery: (requestBody: COMPUTE_ROUTE_DIRECTION_REQUEST) => Promise<ASYNC_RESPONSE<COMPUTE_ROUTE>>;
    static findRoute_with_static_part: (requestBody: COMPUTE_ROUTE_REQUEST) => ASYNC_RESPONSE<COMPUTE_ROUTE>;
    static findRoute_with_static_part_start_floating: (requestBody: COMPUTE_ROUTE_REQUEST) => ASYNC_RESPONSE<COMPUTE_ROUTE>;
    static findRoute_with_static_part_withGraph: (requestBody: COMPUTE_ROUTE_REQUEST) => Promise<ASYNC_RESPONSE<ROUTE_WITH_GRAPH>>;
    static findRoute_with_static_part_withGraph_start_floating: (requestBody: COMPUTE_ROUTE_REQUEST) => Promise<ASYNC_RESPONSE<ROUTE_WITH_GRAPH>>;
    static findRoute_static_part_graph_start_floating_on_dynamic: (requestBody: COMPUTE_ROUTE_REQUEST) => Promise<ASYNC_RESPONSE<ROUTE_WITH_GRAPH>>;
    static findRoute_start_finish_floating: (requestBody: COMPUTE_ROUTE_DIRECTION_REQUEST) => Promise<ASYNC_RESPONSE<COMPUTE_ROUTE>>;
    static findRoute_start_finish_floating_withDirection: (requestBody: COMPUTE_ROUTE_DIRECTION_REQUEST) => Promise<ASYNC_RESPONSE<COMPUTE_ROUTE>>;
    static pointsStraightFilter: (pointsArr: POINT3D[], accuracyDigits: number) => POINT3D[];
}
